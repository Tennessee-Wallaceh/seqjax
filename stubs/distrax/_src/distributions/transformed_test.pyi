from _typeshed import Incomplete
from absl.testing import parameterized
from distrax._src.bijectors import (
    block as block,
    lambda_bijector as lambda_bijector,
    masked_coupling as masked_coupling,
    scalar_affine as scalar_affine,
    sigmoid as sigmoid,
)
from distrax._src.distributions import normal as normal, transformed as transformed
from distrax._src.utils import conversion as conversion

tfd: Incomplete
tfb: Incomplete

class TransformedTest(parameterized.TestCase):
    seed: Incomplete
    def setUp(self) -> None: ...
    def test_event_shape(self, mu, sigma, base_dist) -> None: ...
    def test_dtype_is_consistent_with_tfp(self, dist_fn, bijector_fn) -> None: ...
    def test_dtype_is_as_expected(
        self, dist_fn, bijector_fn, expected_dtype
    ) -> None: ...
    def test_sample_shape(self, mu, sigma, sample_shape, base_dist): ...
    def test_log_prob(self, mu, sigma, value, base_dist) -> None: ...
    def test_prob(self, mu, sigma, value, base_dist) -> None: ...
    def test_sample_and_log_prob(self, mu, sigma, sample_shape, base_dist): ...
    def test_batched_bijector_shapes(self, batch_shape, sample_shape) -> None: ...
    def test_batched_bijector_against_tfp(
        self, bijector_fn, block_ndims, bijector_shape, params_shape
    ) -> None: ...
    def test_raises_on_incorrect_shape(self, block_dims) -> None: ...
    def test_bijector_that_assumes_batch_dimensions(self): ...
    def test_method(self, function_string, mu, sigma, base_dist) -> None: ...
    def test_integer_inputs(self, inputs, base_dist) -> None: ...
    def test_kl_divergence(self, mode_string): ...
    def test_kl_divergence_on_same_instance_of_distrax_bijector(self) -> None: ...
    def test_kl_divergence_raises_on_event_shape(self): ...
    def test_kl_divergence_raises_on_different_bijectors(self): ...
    def test_jittable(self): ...
